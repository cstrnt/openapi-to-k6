import fs from 'fs'
import os from 'os'
import path from 'path'
import { promisify } from 'util'
import {
  afterAll,
  afterEach,
  beforeAll,
  beforeEach,
  describe,
  expect,
  it,
} from 'vitest'
import { Mode } from '../../src/constants'
import { NoFilesGeneratedError } from '../../src/errors'
import generator from '../../src/generator'

const writeFile = promisify(fs.writeFile)
const readFile = promisify(fs.readFile)
const mkdtemp = promisify(fs.mkdtemp)
const rmdir = promisify(fs.rmdir)

const fixturesDir = path.join(__dirname, 'fixtures')

const loadFixture = (filename: string) => {
  const filePath = path.join(fixturesDir, filename)
  const data = fs.readFileSync(filePath, 'utf-8')
  return JSON.parse(data)
}

const commonSubstringsForAllSDK = [
  'Automatically generated by',
  'Do not edit manually',
  'Service version',
  'const mergedRequestParameters = this._mergeRequestParameters( requestParameters || {}, this.commonRequestParameters, );',
  'try { data = response.json(); } catch { data = response.body; }',
  'return { response, data, };',
]

const commonSubstringsForK6SampleScript = [`const baseUrl = "<BASE_URL>";`]

function replaceSpacesAndNewLineToSingleSpace(input: string): string {
  return input.replace(/\s+/g, ' ')
}

describe('generator', () => {
  let tempDir: string, schemaDirectory: string
  const allFixtures = fs.readdirSync(path.join(fixturesDir, 'schemas'))

  beforeAll(async () => {
    tempDir = await mkdtemp(path.join(os.tmpdir(), 'sdk-generator-'))
  })

  afterAll(async () => {
    await rmdir(tempDir, { recursive: true })
  })

  for (const fixtureName of allFixtures) {
    describe(`test ${fixtureName} OpenAPI schema`, () => {
      let openApiPath: string, generatedSchemaPath: string
      const fixture = loadFixture(path.join('schemas', fixtureName))

      beforeEach(async () => {
        schemaDirectory = await mkdtemp(
          path.join(tempDir, fixtureName.replace('.', '-'))
        )
        // Write the OpenAPI schema to a file

        openApiPath = path.join(schemaDirectory, 'openapi-schema.json')

        await writeFile(openApiPath, JSON.stringify(fixture['openapi_schema']))

        generatedSchemaPath = path.join(schemaDirectory, 'generated-schema')
      })

      afterEach(async () => {
        await rmdir(schemaDirectory, { recursive: true })
      })

      it(`should generate SDK client from the OpenAPI schema`, async () => {
        const expectedGeneratedCode = fixture['expected_sdk']

        await generator({
          openApiPath,
          outputDir: generatedSchemaPath,
          mode: Mode.SINGLE,
        })

        const generatedFiles = fs.readdirSync(generatedSchemaPath)
        expect(generatedFiles.length).toBe(1)
        expect(generatedFiles[0]).toBeDefined()
        const fileName = path.basename(generatedFiles[0]!)
        expect(fileName).toBe(expectedGeneratedCode.fileName)
        const generatedFilePath = path.join(
          generatedSchemaPath,
          generatedFiles[0]!
        )
        const generatedContent = await readFile(generatedFilePath, 'utf-8')

        for (const expectedString of [
          ...expectedGeneratedCode['expectedSubstrings'],
          ...commonSubstringsForAllSDK,
        ]) {
          expect(
            replaceSpacesAndNewLineToSingleSpace(generatedContent)
          ).toContain(expectedString)
        }
      })

      it('should generate a sample K6 script', async () => {
        await generator({
          openApiPath,
          outputDir: generatedSchemaPath,
          shouldGenerateSampleK6Script: true,
          mode: Mode.SINGLE,
        })

        const generatedFiles = fs.readdirSync(generatedSchemaPath)
        expect(generatedFiles.length).toBe(2)
        const k6ScriptFile = generatedFiles.find((file) =>
          file.includes('k6-script')
        )
        expect(k6ScriptFile).toBeDefined()
        expect(k6ScriptFile).toBe('k6-script.sample.ts')

        const generatedFilePath = path.join(generatedSchemaPath, k6ScriptFile!)
        const generatedContent = await readFile(generatedFilePath, 'utf-8')

        for (const expectedString of [...commonSubstringsForK6SampleScript]) {
          expect(generatedContent).toContain(expectedString)
        }
      })

      it('should not contain types in main file when using split mode', async () => {
        await generator({
          openApiPath,
          outputDir: generatedSchemaPath,
          shouldGenerateSampleK6Script: true,
          mode: Mode.SPLIT,
        })
        const expectedGeneratedCode = fixture['expected_sdk']
        const generatedFiles = fs.readdirSync(generatedSchemaPath)

        expect(generatedFiles.length).toBe(3)

        const clientFile = generatedFiles.find((file) =>
          file.includes(expectedGeneratedCode.fileName)
        )
        const schemaFile = generatedFiles.find((file) =>
          file.includes('.schemas.ts')
        )

        expect(clientFile).toBeDefined()
        expect(schemaFile).toBeDefined()

        const generatedFilePath = path.join(generatedSchemaPath, clientFile!)
        const generatedContent = await readFile(generatedFilePath, 'utf-8')

        expect(generatedContent).not.toContain('export type')
        expect(generatedContent).not.toContain('export interface')
      })
    })
  }

  describe('validate tags filtering', () => {
    let tempDir: string, openApiPath: string
    const tagsFilteringSchema = loadFixture('tags_filtering.json')

    beforeAll(async () => {
      tempDir = await mkdtemp(path.join(os.tmpdir(), 'tags-filtering-test-'))
      openApiPath = path.join(tempDir, 'openapi-schema.json')
      await writeFile(openApiPath, JSON.stringify(tagsFilteringSchema))
    })

    afterAll(async () => {
      await rmdir(tempDir, { recursive: true })
    })

    const generateAndTest = async (
      mode: Mode,
      tags: string[],
      expectedFiles: string[],
      expectedContents: string[],
      unexpectedContents: string[]
    ) => {
      const generatedSchemaPath = path.join(
        tempDir,
        `generated-schema-${mode}-${tags.join('-')}`
      )
      await generator({
        openApiPath,
        outputDir: generatedSchemaPath,
        tags,
        mode,
      })

      const generatedFiles = fs.readdirSync(generatedSchemaPath)
      expect(generatedFiles).to.have.members(expectedFiles)

      for (const file of expectedFiles) {
        if (file.includes('.schemas.ts')) {
          // Skip schemas file
          continue
        }
        const generatedFilePath = path.join(generatedSchemaPath, file)
        const generatedContent = await readFile(generatedFilePath, 'utf-8')

        for (const content of expectedContents) {
          expect(generatedContent).to.contain(content)
        }

        for (const content of unexpectedContents) {
          expect(generatedContent).not.to.contain(content)
        }
      }
    }

    it('should generate only endpoints with specified tags in single mode', async () => {
      await generateAndTest(
        Mode.SINGLE,
        ['users'],
        ['sampleAPI.ts'],
        ['/users'],
        ['/user-profiles', '/pets', '/auth']
      )

      await generateAndTest(
        Mode.SINGLE,
        ['users', 'userProfiles'],
        ['sampleAPI.ts'],
        ['/users', '/user-profiles'],
        ['/pets', '/auth']
      )

      // Invalid tag should not generate any endpoints
      await generateAndTest(
        Mode.SINGLE,
        ['invalid-tag'],
        ['sampleAPI.ts'],
        [],
        ['/users', '/user-profiles', '/pets', '/auth']
      )

      // Empty tags should generate all endpoints
      await generateAndTest(
        Mode.SINGLE,
        [],
        ['sampleAPI.ts'],
        ['/users', '/user-profiles', '/pets', '/auth'],
        []
      )
    })

    it('should generate only endpoints with specified tags in split mode', async () => {
      await generateAndTest(
        Mode.SPLIT,
        ['users'],
        ['sampleAPI.ts', 'sampleAPI.schemas.ts'],
        ['/users'],
        ['/user-profiles', '/pets', '/auth']
      )

      // Test empty tags
      await generateAndTest(
        Mode.SPLIT,
        [],
        ['sampleAPI.ts', 'sampleAPI.schemas.ts'],
        ['/users', '/user-profiles', '/pets', '/auth'],
        []
      )

      // Invalid tag should not generate any endpoints
      // In the single mode it will create the client file which will have only the schemas
      await expect(
        generateAndTest(
          Mode.SPLIT,
          ['invalid-tag'],
          [],
          [],
          ['/users', '/user-profiles', '/pets', '/auth']
        )
      ).rejects.toThrow(NoFilesGeneratedError)

      // Empty tags should generate all endpoints
      await generateAndTest(
        Mode.SPLIT,
        [],
        ['sampleAPI.ts', 'sampleAPI.schemas.ts'],
        ['/users', '/user-profiles', '/pets', '/auth'],
        []
      )
    })

    it('should generate only endpoints with specified tags in tags mode', async () => {
      await generateAndTest(
        Mode.TAGS,
        ['users'],
        ['users.ts', 'sampleAPI.schemas.ts'],
        ['/users'],
        ['/user-profiles', '/pets', '/auth']
      )

      // Empty tags should generate all endpoints
      await generateAndTest(
        Mode.TAGS,
        [],
        [
          'users.ts',
          'sampleAPI.schemas.ts',
          'auth.ts',
          'pets.ts',
          'user-profiles.ts',
        ],
        [], // Skipping test for content
        []
      )
    })
  })
})

describe('validate sample k6 script', async () => {
  const schemaNameToAssertionsMap = {
    'schema_with_examples.json': {
      expected_string: [
        `let id, postItemsIdBody, putItemsIdBody, patchItemsIdBody, postItemsFormUrlEncodedBody, postItemsFormDataBody, params, userId, postId, headers;`,
        `id = "12345-getItemById";`,
        `id = "123450-createItemById";`,
        `id = "123450-updateItemById";`,
        `id = "123450-patchItemById";`,
        `id = "123450-deleteItemById";`,
        `id = "123450-checkItemById";`,
        `userId = "`, // This is generated as random word using faker hence to validating the value
        `postId = "`, // This is generated as random word using faker hence to validating the value
        `postItemsIdBody = { name: "Sample Item", description: "This is a sample description for the item.", };`,
        `putItemsIdBody = { name: "Updated Item Name", description: "Updated description for the item.", };`,
        `patchItemsIdBody = { name: "Partially Updated Item Name", };`,
        `postItemsFormUrlEncodedBody = { name: "Form Encoded Item", description: "Description for form-urlencoded item.", };`,
        `postItemsFormDataBody = { name: "Form Data Item", };`,
        `params = { id: "123450-getItemByIdWithHeader", };`,
        `params = { itemId: "67890", };`,
        `headers = { "X-Auth-Token": "Bearer abcdef12345", "X-Correlation-ID": "correlation-12345", };`,
      ],
    },
    'schema_using_ref_models.json': {
      expected_string: [
        `let id, itemBase, updatedItem, patchItem, formUrlEncodedItem, formDataItem, params, headers, userId, postId;`,
        `id = "12345-getItemById";`,
        `userId = "`, // This is generated as random word using faker hence to validating the value
        `postId = "`, // This is generated as random word using faker hence to validating the value
        `itemBase = { name: "Sample Item", description: "This is a sample description for the item.", };`,
        `updatedItem = { name: "Updated Item Name", description: "Updated description for the item.", };`,
        `patchItem = { name: "Partially Updated Item Name", };`,
        `formUrlEncodedItem = { name: "Form Encoded Item", description: "Description for form-urlencoded item.", };`,
        `formDataItem = { name: "Form Data Item", };`,
        `params = { id: "123450-getItemByIdWithHeader", };`,
        `headers = { "X-Client-ID": "client-123", };`,
        `params = { itemId: "67890", };`,
        `headers = { "X-Auth-Token": "Bearer abcdef12345", "X-Correlation-ID": "correlation-12345", };`,
      ],
    },
  }

  for (const [schemaName, assertions] of Object.entries(
    schemaNameToAssertionsMap
  )) {
    describe(`test ${schemaName} schema`, () => {
      let tempDir: string, openapiSchemaPath: string

      beforeAll(async () => {
        tempDir = await mkdtemp(
          path.join(os.tmpdir(), `example-k6-script-test-${schemaName}`)
        )
        openapiSchemaPath = path.join(tempDir, 'openapi-schema.json')
        await writeFile(
          openapiSchemaPath,
          JSON.stringify(loadFixture(schemaName))
        )
      })

      it('should generate sample k6 script with correct example values', async () => {
        const generatedClientPath = path.join(tempDir, `generated-client`)

        await generator({
          openApiPath: openapiSchemaPath,
          outputDir: generatedClientPath,
          mode: Mode.SINGLE,
          shouldGenerateSampleK6Script: true,
        })

        const generatedFiles = fs.readdirSync(generatedClientPath)
        expect(generatedFiles.length).toBe(2)

        // Get the k6 script file
        const k6ScriptFile = generatedFiles.find((file) =>
          file.includes('k6-script.sample.ts')
        )
        expect(k6ScriptFile).toBeDefined()

        const k6ScriptFilePath = path.join(generatedClientPath, k6ScriptFile!)
        const k6ScriptContent = await readFile(k6ScriptFilePath, 'utf-8')

        for (const expectedString of assertions.expected_string) {
          expect(
            replaceSpacesAndNewLineToSingleSpace(k6ScriptContent)
          ).toContain(expectedString)
        }
      })
    })
  }
})
